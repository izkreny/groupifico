Project groupifico {
  database_type: 'SQLite'
}

// RELATIONSHIPS
// One  to Many:  "<"  …  users.id      < posts.user_id
// Many to  One:  ">"  …  posts.user_id > users.id
// One  to  One:  "-"  …  users.id      - user_profiles.user_id
Ref: users.id     < members.user_id       [delete: cascade,  update: cascade]
Ref: users.id     - user_profiles.user_id [delete: cascade,  update: cascade]
Ref: groups.id    < members.group_id      [delete: cascade,  update: cascade]
Ref: groups.id    < events.group_id       [delete: cascade,  update: cascade]
Ref: events.id    < attendees.event_id    [delete: cascade,  update: cascade]
Ref: members.id   < attendees.member_id   [delete: cascade,  update: cascade]
Ref: addresses.id < groups.address_id     [delete: restrict, update: cascade]
Ref: addresses.id < events.address_id     [delete: restrict, update: cascade]
// ActiveRecord Associations only (Relationships without SQL Foreign Keys constraints)
Ref: members.id   < events.creator_id     [delete: set default, update: cascade]
Ref: members.id   < events.manager_id     [delete: set null,    update: cascade]

// TABLES & ENUMS
Table users {
  ~primary_key
  email VARCHAR(250) [not null, unique, note: 'case_sensitive: false']
  ~timestamps
}

Table user_profiles {
  ~primary_key
  user_id      INTEGER      [unique, not null]
  username     VARCHAR(50)  [unique, not null, note: 'automaticaly generated random UID'] // TODO
  first_name   VARCHAR(250)
  last_name    VARCHAR(250)
  time_zone    VARCHAR(250) [not null, note: 'resolved via browser'] // TODO: as separate entity?!?
  mobile_phone VARCHAR(50)  [unique]
  ~timestamps
}

Table groups {
  ~primary_key
  address_id  INTEGER      [null]
  username    VARCHAR(50)  [unique, not null] // TODO: additional validation check on application level
  name        VARCHAR(250) [not null]
  description TEXT(100000) // TODO: as field in separate group_profiles table?
  time_zone   VARCHAR(250) // TODO: Maybe?!?
  group_type  group_type   [not null] // TODO: default value based on hostname
  ~timestamps
}

Enum group_type {
  group
  choir
  band
}

Table members {
  ~primary_key
  user_id  INTEGER       [not null]
  group_id INTEGER       [not null]
  status   member_status [not null, default: 'active']
  role     member_role   [not null, default: 'member']
  ~timestamps

  Note: 'Index: User can not become a Member of the same Group twice i.e. Group can not have two Members that belong to the same User'
}

Enum member_status {
  active
  paused
  inactive
}

Enum member_role {
  owner
  member
  admin
  manager
}

Table events {
  ~primary_key
  group_id    INTEGER      [not null]
  creator_id  INTEGER      [not null]
  manager_id  INTEGER      [null]
  address_id  INTEGER      [null]
  uid         VARCHAR(15)  [not null] // TODO
  name        VARCHAR(250) [not null]
  description TEXT(100000)
  start       DATETIME     [not null]
  end         DATETIME     [not null]
  time_zone   VARCHAR(250) // TODO: Maybe?!?
  status      event_status [not null, default: 'unconfirmed'] // TODO: implement business logic aka validation depending on existence of manager(?!?) and address data
  event_type  event_type   [not null] // TODO: Create special entity with event types, maybe based on group_type (as special Entity itself)? Also make it optional?
  ~timestamps
}

Enum event_status {
  unconfirmed
  confirmed
  concluded
  canceled
}

Enum event_type {
  other
  rehearsal
  gig
}

Table attendees {
  ~primary_key
  member_id INTEGER         [not null]
  event_id  INTEGER         [not null]
  status    attendee_status [not null, default: 'reserved']
  ~timestamps

  Note: 'Index: Member can not become an Attendee of the same Event twice i.e. Event can not have two Attendees that belong to the same Member'
}

Enum attendee_status {
  reserved
  invited
  yes
  maybe
  no
}

Table addresses {
  ~primary_key
  name            VARCHAR(250) [not null]
  street_name     VARCHAR(250)
  building_number VARCHAR(250)
  city            VARCHAR(250)
  postal_code     VARCHAR(100)
  state_code      VARCHAR(50)  [note: 'ISO 3166-2 code']
  country_code    VARCHAR(5)   [note: 'ISO 3166-1 alpha-2 code']
  latitude        FLOAT        [note: 'user can not edit']
  longitude       FLOAT        [note: 'user can not edit']
  ~timestamps

  Note: 'Based on ISO 20022 PostalAddress type'
}

// TABLE PARTIALS
TablePartial primary_key {
  id INTEGER [primary key, unique, increment, not null]
}

TablePartial timestamps {
  created_at DATETIME(6) [not null]
  updated_at DATETIME(6) [not null]
}
